# -*- coding: utf-8 -*-
"""
Part of the astor library for Python AST manipulation.

License: 3-clause BSD

Copyright (c) 2008      Armin Ronacher
Copyright (c) 2012-2017 Patrick Maupin
Copyright (c) 2013-2017 Berker Peksag

This module converts an AST into Python source code.

Before being version-controlled as part of astor,
this code came from here (in 2012):

    https://gist.github.com/1250562

"""

import ast
import sys
import gc

from .op_util import get_op_symbol, get_op_precedence, Precedence
from .node_util import ExplicitNodeVisitor
from .prettifier import StringLiteral, beautify

###################################################################
#               Main interface
###################################################################

def to_source(node, indent_with=' ' * 4, add_line_information=False,
              disable_gc=True, beautify=beautify):
    """This function can convert a node tree back into python sourcecode.
    This is useful for debugging purposes, especially if you're dealing with
    custom asts not generated by python itself.

    It could be that the sourcecode is evaluable when the AST itself is not
    compilable / evaluable.  The reason for this is that the AST contains some
    more data than regular sourcecode does, which is dropped during
    conversion.

    Each level of indentation is replaced with `indent_with`.  Per default this
    parameter is equal to four spaces as suggested by PEP 8, but it might be
    adjusted to match the application's styleguide.

    If `add_line_information` is set to `True` comments for the line numbers
    of the nodes are added to the output.  This can be used to spot wrong line
    number information of statement nodes.

    """
    disable_gc = disable_gc and gc.isenabled()
    if disable_gc:
        gc.disable()
    try:
        generator = SourceGenerator(indent_with, add_line_information)
        generator.write(node)
        result = generator.result
        beautify(result)
        result.append(['\n'])
        if set(result[0][0]) == set('\n'):
            result[0][0] = ''
        return ''.join(s for lst in result for s in lst)
    finally:
        if disable_gc:
            #del generator
            gc.enable()


###################################################################
#               Utility functions, classes, and instances
###################################################################

# These are here so that they may be statically bound at compile
# time for efficiency.

class LineFeed(object):
    """ A class of a special object that causes a linefeed
        to be inserted in the output.
    """

linefeed = LineFeed()


def precedence_setter(AST=ast.AST, get_op_precedence=get_op_precedence,
                      isinstance=isinstance, list=list):
    """ This only uses a closure for performance reasons,
        to reduce the number of attribute lookups.  (set_precedence
        is called a lot of times.)
    """

    def set_precedence(value, *nodes):
        """ Set the precedence (of the parent) into the children.

            The purpose of setting the precedence is to be able
            to determine if parentheses are needed at any level
            of an expression.
        """
        if isinstance(value, AST):
            value = get_op_precedence(value)
        for node in nodes:
            if isinstance(node, AST):
                node._pp = value
            elif isinstance(node, list):
                set_precedence(value, *node)
            else:
                assert node is None, node

    return set_precedence


set_precedence = precedence_setter()


def conditional(*params):
    """ If the last param evaluates to None, just return
        an empty tuple
    """
    return params if params[-1] is not None else ()


def comma_group(items, trailing=False,
                # Constants
                set_precedence=set_precedence,
                Comma=Precedence.Comma, enumerate=enumerate):
    """ Print a group of 0 or more items, with commas between,
        and an optional trailing comma.
    """
    set_precedence(Comma, *items)
    yield (((', ', item) if idx else item)
                for idx, item in enumerate(items))
    if trailing:
        yield ','


def else_body(node,
              # Constants
              If=ast.If, set_precedence=set_precedence,
              linefeed=linefeed, type=type, len=len):
    """ Perform the ugly logic to coalesce multiple ifs
        together with elif.
    """
    orelse = node.orelse
    while orelse:
        if len(orelse) == 1 and type(orelse[0]) is If is type(node):
            node = orelse[0]
            set_precedence(node, node.test)
            yield linefeed, 'elif ', node.test, ':', node.body
            orelse = node.orelse
        else:
            yield linefeed, 'else:', orelse
            return


def get_step(node,
             # Constants
             Name=ast.Name, isinstance=isinstance):
    """ Perform the ugly logic to get the step for a slice.
        If there is a step, but it is None, we don't display
        the None.
    """
    if node.step is not None:
        yield ':'
        if (isinstance(node.step, Name) and
                node.step.id == 'None'):
            pass
        yield node.step


def with_item(node,
              # Constants
              conditional=conditional):
    """ This is only a separate function so that it can be shared
        between the Python 2 and Python 3 code, which implement
        the with statement slightly differently.
    """
    return (node.context_expr, conditional(' as ', node.optional_vars))



class CommaSeparator(object):
    value=()


class Delimit(object):
    """A context manager that can add enclosing
       delimiters around the output of a
       SourceGenerator method.  By default, the
       parentheses are added, but the enclosed code
       may set discard=True to get rid of them,
       e.g. if it turns out that parentheses are not
       needed around an expression.
    """

    discard = False

    def __init__(self, tree, args,
                 # Constants
                 AST=ast.AST, isinstance=isinstance, len=len):
        """ use write instead of using result directly
            for initial data, because it may flush
            preceding linefeed data into result.
        """
        delimiters = '()'
        node = None
        op = None
        for arg in args:
            if isinstance(arg, AST):
                if node is None:
                    node = arg
                else:
                    op = arg
            else:
                delimiters = arg
        tree.write(delimiters[0])
        result = self.result = tree.result[-1]
        self.index = len(result)
        self.closing = delimiters[1]
        if node is not None:
            self.p = p = get_op_precedence(op or node)
            self.pp = pp = tree.get__pp(node)
            self.discard = p >= pp

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        result = self.result
        start = self.index - 1
        if self.discard:
            del result[start]
        else:
            result.append(self.closing)


###################################################################
#               Main class
###################################################################

class SourceGenerator(dict):
    """ This visitor is able to transform a well formed syntax tree
        into Python sourcecode.

        For more details,look at the `to_source` function.

        The reason this subclasses a dictionary is that the dict is
        used to memoize the AST class -> visitor mapping.
    """

    # Goofy from __future__ string handling for 2.7
    using_unicode_literals = False


    ###################################################################
    #               Top-level tree constructs
    ###################################################################

    # Normal entry path
    def visit_Module(self, node):
        self.write(node.body)

    # Code compiled with 'eval' or 'single'
    visit_Interactive = visit_Module
    visit_Expression = visit_Module

    ###################################################################
    #                      Statements
    ###################################################################

    def visit_AnnAssign(self, node):
        """ Annotated assignment """
        set_precedence(node, node.target, node.annotation)
        set_precedence(Precedence.Comma, node.value)
        need_parens = isinstance(node.target, ast.Name) and not node.simple
        target_str = ('(', node.target, ')') if need_parens else node.target
        self.statement(node, target_str, ': ', node.annotation,
                       conditional(' = ', node.value))

    def visit_Assert(self, node):
        set_precedence(node, node.test, node.msg)
        self.statement(node, 'assert ', node.test, conditional(', ', node.msg))

    def visit_Assign(self, node, set_precedence=set_precedence):
        set_precedence(node, node.value, *node.targets)
        self.statement(node, ((target, ' = ') for target in node.targets),
                       node.value)

    # introduced in Python 3.5
    def visit_AsyncFor(self, node):
        self.visit_For(node, keyword='async for ')

    # introduced in Python 3.5
    def visit_AsyncFunctionDef(self, node):
        self.visit_FunctionDef(node, keyword='async def ')

    # new for Python 3.5
    def visit_AsyncWith(self, node):
        self.visit_With(node, keyword='async with ')

    def visit_AugAssign(self, node, set_precedence=set_precedence):
        set_precedence(node, node.value, node.target)
        self.statement(node, node.target, get_op_symbol(node.op, ' %s= '),
                       node.value)

    def visit_Break(self, node):
        self.statement(node, 'break')

    def visit_Continue(self, node):
        self.statement(node, 'continue')

    def visit_ClassDef(self, node):
        paren_or_comma = CommaSeparator()
        paren_or_comma.value = '('

        def separator():
            """ Don't access paren_or_comma until we're done """
            self.write(':' if paren_or_comma.value == '(' else '):')

        self.decorators(node, 2)
        self.statement(node, 'class ', node.name,
                    ((paren_or_comma, base) for base in node.bases),
                    ((paren_or_comma,
                        (keyword.arg, '=') if keyword.arg else '**',
                        keyword.value) for keyword in self.get_keywords(node)),
                    conditional(paren_or_comma, '*', self.get_starargs(node)),
                    conditional(paren_or_comma, '**', self.get_kwargs(node)),
                    separator, node.body)
        if not self.indentation:
            self.newline(extra=2)

    def visit_Delete(self, node):
        self.statement(node, 'del ', comma_group(node.targets))

    def visit_Expr(self, node, set_precedence=set_precedence):
        """ Expression not in an assignment.
            Usually a call or a docstring.
        """
        set_precedence(node, node.value)
        self.statement(node, node.value)

    def visit_ExceptHandler(self, node):
        type_ = conditional(' ', node.type)
        type_ = (type_, conditional(' as ', node.name)) if type_ else type_
        self.statement(node, 'except', type_, ':', node.body)

    def visit_Exec(self, node):
        dicts = node.globals, node.locals
        dicts = dicts[::-1] if dicts[0] is None else dicts
        self.statement(node, 'exec ', node.body, conditional(' in ', dicts[0]),
                       conditional(', ', dicts[1]))

    def visit_For(self, node, keyword='for ', set_precedence=set_precedence):
        set_precedence(node, node.target)
        self.statement(node, keyword, node.target, ' in ', node.iter, ':',
                       node.body, else_body(node))

    def visit_FunctionDef(self, node, keyword='def '):
        self.decorators(node, 1 if self.indentation else 2)
        returns = self.get_returns(node)
        returns = ('->', returns, ':') if returns else ':'
        self.statement(node, keyword, node.name, '(', node.args, ')',
                       returns, node.body)
        if not self.indentation:
            self.newline(extra=2)

    def visit_Global(self, node):
        self.statement(node, 'global ', ', '.join(node.names))

    def visit_If(self, node, set_precedence=set_precedence):
        set_precedence(node, node.test)
        self.statement(node, 'if ', node.test, ':', node.body,
                       else_body(node))

    def visit_Import(self, node):
        self.statement(node, 'import ', comma_group(node.names))

    def visit_ImportFrom(self, node):
        self.statement(node, 'from ', node.level * '.',
                       node.module or '', ' import ',
                       comma_group(node.names))

        # Goofy stuff for Python 2.7 _pyio module
        if node.module == '__future__' and 'unicode_literals' in (
                x.name for x in node.names):
            self.using_unicode_literals = True

    def visit_Nonlocal(self, node):
        self.statement(node, 'nonlocal ', ', '.join(node.names))

    def visit_Pass(self, node):
        self.statement(node, 'pass')

    def visit_Print(self, node):
        # python 2.6 only
        self.statement(node, 'print ')
        values = node.values
        if node.dest is not None:
            self.write(' >> ')
            values = [node.dest] + values
        self.write(comma_group(values, not node.nl))

    def visit_Raise(self, node, conditional=conditional):
        # Python 2.6 / 3.0 differences here
        exc = conditional(' ', self.get_exc(node))
        exc = exc and (exc, conditional(' from ', node.cause))
        if not exc:
            exc = conditional(' ', self.get_type(node))
            if exc:
                set_precedence(node, node.inst)
                exc = (exc, conditional(', ', node.inst),
                       conditional(', ', node.tback))
        self.statement(node, 'raise', exc)

    def visit_Return(self, node, set_precedence=set_precedence):
        set_precedence(node, node.value)
        self.statement(node, 'return', conditional(' ', node.value))

    # new for Python 3.3
    def visit_Try(self, node):
        self.statement(node, 'try:', node.body, iter(node.handlers),
                       else_body(node))
        if node.finalbody:
            self.statement(node, 'finally:', node.finalbody)

    def visit_TryExcept(self, node):
        self.statement(node, 'try:', node.body, iter(node.handlers),
                       else_body(node))

    def visit_TryFinally(self, node):
        self.statement(node, 'try:', node.body)
        self.statement(node, 'finally:', node.finalbody)

    def visit_While(self, node, set_precedence=set_precedence):
        set_precedence(node, node.test)
        self.statement(node, 'while ', node.test, ':', node.body,
                       else_body(node))

    def visit_With(self, node, keyword='with ', hasattr=hasattr):
        """ Pythons before 3.3 used a context_expr; pythons after that use
            a list of contexts items.
        """
        old_way = hasattr(node, "context_expr")
        self.statement(node, keyword, with_item(node) if old_way
                       else comma_group(node.items), ':', node.body)

    ###################################################################
    #               Expression operators
    ###################################################################

    def visit_Attribute(self, node):
        self.write(node.value, '.', node.attr)

    def visit_BinOp(self, node,
                    # Constants
                    set_precedence=set_precedence, Pow=ast.Pow,
                    get_op_symbol=get_op_symbol, isinstance=isinstance):
        op, left, right = node.op, node.left, node.right
        with self.delimit(node, op) as delimiters:
            ispow = isinstance(op, Pow)
            p = delimiters.p
            set_precedence((Precedence.Pow + 1) if ispow else p, left)
            set_precedence(Precedence.PowRHS if ispow else (p + 1), right)
            self.write(left, get_op_symbol(op, ' %s '), right)

    def visit_BoolOp(self, node,
                     #Constants
                     set_precedence=set_precedence,
                     get_op_symbol=get_op_symbol, enumerate=enumerate):
        with self.delimit(node, node.op) as delimiters:
            set_precedence(delimiters.p + 1, *node.values)
            op = get_op_symbol(node.op, ' %s ')
            self.write(((op, value) if idx else value)
                        for idx, value in enumerate(node.values))


    def visit_Compare(self, node,
                      #Constants
                     set_precedence=set_precedence,
                     get_op_symbol=get_op_symbol, zip=zip):
        with self.delimit(node, node.ops[0]) as delimiters:
            set_precedence(delimiters.p + 1, node.left, *node.comparators)
            self.write(node.left, ((get_op_symbol(op, ' %s '), right)
                        for op, right in zip(node.ops, node.comparators)))

    def visit_ExtSlice(self, node):
        dims = node.dims
        set_precedence(node, *dims)
        self.write(comma_group(dims, len(dims) == 1))

    def visit_IfExp(self, node):
        with self.delimit(node) as delimiters:
            set_precedence(delimiters.p + 1, node.body, node.test)
            set_precedence(delimiters.p, node.orelse)
            self.write(node.body, ' if ', node.test, ' else ', node.orelse)

    def visit_Index(self, node, set_precedence=set_precedence):
        with self.delimit(node) as delimiters:
            set_precedence(delimiters.p, node.value)
            self.write(node.value)

    def visit_Slice(self, node,
                    # Constants
                    conditional=conditional, get_step=get_step,
                    set_precedence=set_precedence):
        set_precedence(node, node.lower, node.upper, node.step)
        self.write(conditional(node.lower), ':', conditional(node.upper),
                   get_step(node))

    def visit_Subscript(self, node, set_precedence=set_precedence):
        set_precedence(node, node.slice)
        self.write(node.value, '[', node.slice, ']')

    def visit_UnaryOp(self, node,
                    # Constants
                    conditional=conditional, get_op_symbol=get_op_symbol,
                    set_precedence=set_precedence):
        with self.delimit(node, node.op) as delimiters:
            set_precedence(delimiters.p, node.operand)
            # In Python 2.x, a unary negative of a literal
            # number is merged into the number itself.  This
            # bit of ugliness means it is useful to know
            # what the parent operation was...
            node.operand._p_op = node.op
            sym = get_op_symbol(node.op)
            # Need a space between alpha operand and a number
            spacer = conditional(' ' if sym.isalpha() else None)
            self.write(sym, spacer, node.operand)


    ###################################################################
    #               Function calls
    ###################################################################

    def visit_Call(self, node,
                   # Comments
                   CommaSeparator=CommaSeparator,
                   Comma=Precedence.Comma, 
                   call_one_arg=Precedence.call_one_arg,
                   conditional=conditional, len=len):
        write_comma = CommaSeparator()

        args = node.args
        keywords = node.keywords
        starargs = self.get_starargs(node)
        kwargs = self.get_kwargs(node)
        numargs = len(args) + len(keywords)
        numargs += starargs is not None
        numargs += kwargs is not None
        p = Comma if numargs > 1 else call_one_arg
        set_precedence(p, *args)
        set_precedence(Comma, *(x.value for x in keywords))

        self.write(node.func, '(', ((write_comma, arg) for arg in args),
                    # a keyword.arg of None indicates dictionary unpacking
                    # (Python >= 3.5)
                    ((write_comma,
                      (keyword.arg, '=') if keyword.arg else '**',
                      keyword.value) for keyword in keywords),
                    # 3.5 no longer has these
                    conditional(write_comma, '*', starargs),
                    conditional(write_comma, '**', kwargs), ')')


    ###################################################################
    #               Expression keywords
    ###################################################################


    # new for Python 3.5
    def visit_Await(self, node):
        with self.delimit(node):
            self.write('await ', node.value)

    def visit_Lambda(self, node):
        with self.delimit(node) as delimiters:
            set_precedence(delimiters.p, node.body)
            self.write('lambda ', node.args, ': ', node.body)

    def visit_Yield(self, node):
        with self.delimit(node):
            set_precedence(get_op_precedence(node) + 1, node.value)
            self.write('yield', conditional(' ', node.value))

    # new for Python 3.3
    def visit_YieldFrom(self, node):
        with self.delimit(node):
            self.write('yield from ', node.value)


    ###################################################################
    #               Container types
    ###################################################################

    def visit_Dict(self, node,
                   # Constants
                   set_precedence=set_precedence, Comma=Precedence.Comma,
                   enumerate=enumerate, zip=zip):
        set_precedence(Precedence.Comma, *node.values)
        with self.delimit('{}'):
            self.write((', ' if idx else (), (key, ': ') if key else '**',
                        value) for idx, (key, value)
                        in enumerate(zip(node.keys, node.values)))

    def visit_List(self, node, comma_group=comma_group):
        with self.delimit('[]'):
            self.write(comma_group(node.elts))

    def visit_Set(self, node, comma_group=comma_group):
        with self.delimit('{}'):
            self.write(comma_group(node.elts))

    def visit_Tuple(self, node, comma_group=comma_group, len=len):
        with self.delimit(node) as delimiters:
            # Two things are special about tuples:
            #   1) We cannot discard the enclosing parentheses if empty
            #   2) We need the trailing comma if only one item
            elts = node.elts
            delimiters.discard = delimiters.discard and elts
            self.write(comma_group(elts, len(elts) == 1))



    ###################################################################
    #               Leaf operands
    ###################################################################



    def visit_Bytes(self, node):
        # TODO: Use fancy new string.....
        self.write(repr(node.s))

    def visit_Ellipsis(self, node):
        self.write('...')

    def visit_JoinedStr(self, node):
        # Flush any pending newlines, because we're about
        # to severely abuse the result list.
        self.write('')

        # Handle new f-strings.  This is a bit complicated, because
        # the tree can contain subnodes that recurse back to JoinedStr
        # subnodes...

        def recurse(node):
            for value in node.values:
                if isinstance(value, ast.Str):
                    self.write(value.s)
                elif isinstance(value, ast.FormattedValue):
                    with self.delimit('{}'):
                        self.write(value.value)
                        if value.conversion != -1:
                            self.write('!%s' % chr(value.conversion))
                        if value.format_spec is not None:
                            self.write(':')
                            recurse(value.format_spec)
                else:
                    kind = type(value).__name__
                    assert False, 'Invalid node %s inside JoinedStr' % kind

        result = self.result[-1]
        index = len(result)
        recurse(node)
        mystr = 'f' + repr(''.join(result[index:]))
        del result[index:]
        self.write(mystr)
        assert result is self.result[-1]

    def visit_Name(self, node):
        self.write(node.id)

    def visit_NameConstant(self, node, str=str):
        self.write(str(node.value))

    def visit_Num(self, node,
                  # constants
                  new=sys.version_info >= (3, 0),
                  repr=repr):
        with self.delimit(node) as delimiters:
            s = repr(node.n)

            # Deal with infinities -- if detected, we can
            # generate them with 1e1000.
            signed = s.startswith('-')
            if s[signed].isalpha():
                im = s[-1] == 'j' and 'j' or ''
                assert s[signed:signed + 3] == 'inf', s
                s = '%s1e1000%s' % ('-' if signed else '', im)
            self.write(s)

            # The Python 2.x compiler merges a unary minus
            # with a number.  This is a premature optimization
            # that we deal with here...
            if not new and delimiters.discard:
                if signed:
                    pow_lhs = Precedence.Pow + 1
                    delimiters.discard = delimiters.pp != pow_lhs
                else:
                    op = self.get__p_op(node)
                    delimiters.discard = not isinstance(op, ast.USub)

    def visit_Repr(self, node):
        # python 2.6 only
        with self.delimit('``'):
            self.write(node.value)

    def visit_Str(self, node,
                  # Constants
                  StringLiteral=StringLiteral, repr=repr):

        s = node.s
        mystr = repr(s)
        prefix = self.using_unicode_literals and isinstance(s, bytes)
        if prefix:
            mystr = StringLiteral('b' + mystr)
            mystr.prefix = 'b'
        else:
            mystr = StringLiteral(mystr)
        mystr.src = s
        self.write(mystr)

    ###################################################################
    #               Comprehensions and generators
    ###################################################################

    def visit_DictComp(self, node):
        with self.delimit('{}'):
            self.write(node.key, ': ', node.value, *node.generators)

    def visit_GeneratorExp(self, node):
        with self.delimit(node) as delimiters:
            if delimiters.pp == Precedence.call_one_arg:
                delimiters.discard = True
            set_precedence(Precedence.Comma, node.elt)
            self.write(node.elt, *node.generators)

    def visit_ListComp(self, node):
        with self.delimit('[]'):
            self.write(node.elt, *node.generators)

    def visit_SetComp(self, node):
        with self.delimit('{}'):
            self.write(node.elt, node.generators)

    ###################################################################
    #               Helper nodes
    ###################################################################

    def visit_alias(self, node, conditional=conditional):
        self.write(node.name, conditional(' as ', node.asname))

    def visit_arg(self, node, conditional=conditional):
        self.write(node.arg, conditional(': ', node.annotation))

    def visit_arguments(self, node,
                        # Constants
                        CommaSeparator=CommaSeparator,
                        set_precedence=set_precedence,
                        Comma=Precedence.Comma,
                        conditional=conditional,
                        len=len, zip=zip):
        write = self.write
        write_comma = CommaSeparator()

        def loop_args(args, defaults):
            set_precedence(Comma, defaults)
            padding = [None] * (len(args) - len(defaults))
            write((write_comma,
                         (arg if default is None else (arg, '=', default)))
                            for arg, default in zip(args, padding + defaults))

        loop_args(node.args, node.defaults)
        write(conditional(write_comma, '*', node.vararg))

        kwonlyargs = self.get_kwonlyargs(node)
        if kwonlyargs:
            if node.vararg is None:
                write(write_comma, '*')
            loop_args(kwonlyargs, node.kw_defaults)
        write(conditional(write_comma, '**', node.kwarg))

    def visit_comprehension(self, node):
        set_precedence(node, node.iter, *node.ifs)
        set_precedence(Precedence.comprehension_target, node.target)
        keyword = ' async for ' if self.get_is_async(node) else ' for '
        self.write(keyword, node.target, ' in ', node.iter,
                    ((' if ', if_) for if_ in node.ifs))

    def visit_Starred(self, node):
        self.write('*', node.value)

    # new for Python 3.3
    def visit_withitem(self, node):
        self.write(with_item(node))


    ###################################################################
    #               non-AST node visitors
    ###################################################################

    def visit_CommaSeparator(self, node):
        """ Helps us print a heterogenous comma-separated list
        """
        self.write(node.value)
        node.value = (', ')

    def visit_LineFeed(self, node):
        """ Visit a linefeed to insert a newline
        """
        self.newline()

    def visit_str(self, item):
        """ At the bottom, everything is a (real) string.  This is not
            the AST Str type; it's the Python interpreter's string.  This
            is where we store things in the result we are building.
        """
        result = self.result
        if self.new_lines:
            result.extend([['\n' * self.new_lines],
                           [self.indent_with * self.indentation]])
            self.new_lines = 0
        result[-1].append(item)

    visit_StringLiteral = visit_str

    def visit_function(self, node):
        """ When we visit a callable, just call it to let it
            do it's thing.
        """
        node()

    visit_method = visit_function
    visit_instancemethod = visit_function


    ###################################################################
    #               Methods called by visitors
    ###################################################################


    def decorators(self, node, extra):
        """ Add decorators in front of a class or function def
        """
        self.newline(extra=extra)
        for decorator in node.decorator_list:
            self.statement(decorator, '@', decorator)

    def delimit(self, *args):
        """ Wrapper to make instantiation of Delimit class a bit cleaner
        """
        return Delimit(self, args)

    def newline(self, extra=0):
        """ Output new lines before the next token
        """
        self.new_lines = max(self.new_lines, 1 + extra)

    def statement(self, node, *params):
        """ A statement starts at the beginning of a line,
            and may have associated line number information
        """
        self.newline()
        if self.add_line_information:
            self.write('# line: %s' % node.lineno)
            self.new_lines = 1
        self.write(*params)

    def __getattr__(self, name, defaults=dict(keywords=(),
                    _pp=Precedence.highest).get):
        """ Get an attribute of the node.
            like dict.get (returns None if doesn't exist)
        """
        if not name.startswith('get_'):
            raise AttributeError
        geta = getattr
        shortname = name[4:]
        default = defaults(shortname)

        def getter(node):
            return geta(node, shortname, default)

        setattr(self, name, getter)
        return getter

    def __missing__(self, nodetype, getattr=getattr):
        """ Cache type -> visitor relationship
        """
        method = 'visit_' + nodetype.__name__
        visitor = getattr(self, method, None)
        if visitor is None:
            msg = 'No defined handler for node of type %s'
            raise AttributeError(msg % method[6:])
        self[nodetype] = visitor
        return visitor


    def __init__(self, indent_with, add_line_information=False):
        """ Initialize the instance, and use a closure for
            writes for faster tree traversal.
        """
        self.result = []
        self.indent_with = indent_with
        self.add_line_information = add_line_information
        self.indentation = -1  # Current indentation level
        self.new_lines = 1  # Number of lines to insert before next code

        type_ = type

        def write(*args):
            """ Main dispatcher
            """
            item = None
            for item in args:
                self[type_(item)](item)
            return item

        def write_iter(args):
            """ Like write() but a single iterable parameter,
                rather than *args.
            """
            item = None
            for item in args:
                self[type_(item)](item)
            return item

        def write_body(statements):
            """ This is what we do when we encounter
                a list in the tree rather than an instance
                of ast.AST.
            """
            self.indentation += 1
            write_iter(statements)
            self.indentation -= 1

        self.write = write

        # Insure that we handle lists, tuples, generators, etc. properly
        self[tuple] =  write_iter
        self[type(x for x in [])] = write_iter
        self[type(iter([]))] = write_iter
        self[type([])] = write_body
